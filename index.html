import React, { useRef, useState, useEffect } from "react"
import * as tf from "@tensorflow/tfjs"
import * as handpose from "@tensorflow-models/handpose"
import Webcam from "react-webcam"
import { drawHand } from "../components/handposeutil"
import * as fp from "fingerpose"
import Handsigns from "../components/handsigns"

import {
  Text,
  Heading,
  Button,
  Image,
  Stack,
  Container,
  Box,
  VStack,
  ChakraProvider,
} from "@chakra-ui/react"

import { Signimage, Signpass } from "../components/handimage"
import About from "../components/about"
import Metatags from "../components/metatags"

import { RiCameraFill, RiCameraOffFill } from "react-icons/ri"

export default function Home() {
  const webcamRef = useRef(null)
  const canvasRef = useRef(null)

  const [camState, setCamState] = useState("on")
  const [sign, setSign] = useState(null)
  const [constructedWord, setConstructedWord] = useState("")

  // stable prediction tracking (refs to avoid excessive renders)
  const stableLetterRef = useRef("") // current repeating candidate letter
  const stableCountRef = useRef(0) // how many times seen consecutively
  const lastAcceptedLetterRef = useRef("") // last accepted letter
  const ACCEPT_THRESHOLD = 3 // require same letter 3 times (adjustable)
  const DETECT_INTERVAL_MS = 150 // detect cadence (from your code)

  let signList = []
  let currentSign = 0
  let gamestate = "started"

  async function runHandpose() {
    const net = await handpose.load()
    _signList()
    setInterval(() => {
      detect(net)
    }, DETECT_INTERVAL_MS)
  }

  function _signList() {
    signList = generateSigns()
  }

  function shuffle(a) {
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[a[i], a[j]] = [a[j], a[i]]
    }
    return a
  }

  function generateSigns() {
    const password = shuffle(Signpass)
    return password
  }

  // Send message into App Inventor WebViewer
  function sendToAppInventor(payload) {
    try {
      if (window.AppInventor && AppInventor.setWebViewString) {
        AppInventor.setWebViewString(payload)
      } else if (
        window.parent &&
        window.parent.AppInventor &&
        window.parent.AppInventor.setWebViewString
      ) {
        window.parent.AppInventor.setWebViewString(payload)
      } else {
        // Not embedded — for dev we can console.log
        // console.log("AppInventor payload:", payload)
      }
    } catch (e) {
      console.warn("AppInventor bridge error", e)
    }
  }

  // Accept a stable detected letter
  function acceptLetter(letter) {
    // avoid duplicate immediate repeats if desired:
    if (lastAcceptedLetterRef.current === letter) {
      // optional: you may still want to append repeated letters (e.g., double letters)
      // return
    }
    lastAcceptedLetterRef.current = letter
    setSign(letter)
    setConstructedWord(prev => {
      const next = prev + letter
      // Send both the latest letter and the full word to App Inventor
      sendToAppInventor(`LETTER:${letter}`)
      sendToAppInventor(`WORD:${next}`)
      return next
    })
    // Also speak via browser (optional)
    try {
      const utter = new SpeechSynthesisUtterance(letter)
      window.speechSynthesis.speak(utter)
    } catch (e) {}
  }

  async function detect(net) {
    if (
      typeof webcamRef.current !== "undefined" &&
      webcamRef.current !== null &&
      webcamRef.current.video.readyState === 4
    ) {
      const video = webcamRef.current.video
      const videoWidth = webcamRef.current.video.videoWidth
      const videoHeight = webcamRef.current.video.videoHeight

      webcamRef.current.video.width = videoWidth
      webcamRef.current.video.height = videoHeight

      canvasRef.current.width = videoWidth
      canvasRef.current.height = videoHeight

      const hand = await net.estimateHands(video)

      if (hand.length > 0) {
        const GE = new fp.GestureEstimator([
          fp.Gestures.ThumbsUpGesture,
          Handsigns.aSign,
          Handsigns.bSign,
          Handsigns.cSign,
          Handsigns.dSign,
          Handsigns.eSign,
          Handsigns.fSign,
          Handsigns.gSign,
          Handsigns.hSign,
          Handsigns.iSign,
          Handsigns.jSign,
          Handsigns.kSign,
          Handsigns.lSign,
          Handsigns.mSign,
          Handsigns.nSign,
          Handsigns.oSign,
          Handsigns.pSign,
          Handsigns.qSign,
          Handsigns.rSign,
          Handsigns.sSign,
          Handsigns.tSign,
          Handsigns.uSign,
          Handsigns.vSign,
          Handsigns.wSign,
          Handsigns.xSign,
          Handsigns.ySign,
          Handsigns.zSign,
        ])

        const estimatedGestures = await GE.estimate(hand[0].landmarks, 6.5)

        if (gamestate === "started") {
          document.querySelector("#app-title").innerText =
            "Make a 👍 gesture with your hand to start"
        }

        if (
          estimatedGestures.gestures !== undefined &&
          estimatedGestures.gestures.length > 0
        ) {
          const confidence = estimatedGestures.gestures.map(p => p.confidence)
          const maxConfidence = confidence.indexOf(
            Math.max.apply(undefined, confidence)
          )

          // if user triggers thumbs_up to start game
          if (
            estimatedGestures.gestures[maxConfidence].name === "thumbs_up" &&
            gamestate !== "played"
          ) {
            _signList()
            gamestate = "played"
            document.getElementById("emojimage").classList.add("play")
            document.querySelector(".tutor-text").innerText =
              "make a hand gesture based on letter shown below"
          } else if (gamestate === "played") {
            document.querySelector("#app-title").innerText = ""

            if (currentSign === signList.length) {
              _signList()
              currentSign = 0
              return
            }

            if (
              typeof signList[currentSign].src.src === "string" ||
              signList[currentSign].src.src instanceof String
            ) {
              document
                .getElementById("emojimage")
                .setAttribute("src", signList[currentSign].src.src)

              // predicted gesture name (e.g., 'a_sign' or 'a' depending on your Handsigns definitions)
              const predictedName =
                estimatedGestures.gestures[maxConfidence].name

              // map predictedName to a single-letter label if needed:
              // if your Handsigns use names like 'a_sign' or 'a', normalize:
              let predictedLetter = predictedName
              // attempt normalization (common repo naming: 'aSign' earlier, but fingerpose name might be 'a')
              // For safety, strip non-letter characters and take first letter:
              if (typeof predictedLetter === "string") {
                // attempt to find an actual letter within the predicted name
                const match = predictedLetter.match(/[a-zA-Z]/)
                if (match) {
                  predictedLetter = match[0].toUpperCase()
                } else {
                  // fallback: set to empty (ignore)
                  predictedLetter = ""
                }
              }

              // STABLE ACCEPTANCE LOGIC:
              if (predictedLetter && predictedLetter.length === 1) {
                if (stableLetterRef.current === predictedLetter) {
                  stableCountRef.current = stableCountRef.current + 1
                } else {
                  stableLetterRef.current = predictedLetter
                  stableCountRef.current = 1
                }

                if (stableCountRef.current >= ACCEPT_THRESHOLD) {
                  // Accept this letter
                  acceptLetter(predictedLetter)
                  // reset stable tracking so same letter can be accepted again after new detections
                  stableLetterRef.current = ""
                  stableCountRef.current = 0
                }
              } else {
                // no letter predicted, reset counters slowly
                stableLetterRef.current = ""
                stableCountRef.current = 0
              }

              setSign(predictedLetter)
              // advance game if matched etc (existing logic)
              if (
                signList[currentSign].alt ===
                estimatedGestures.gestures[maxConfidence].name
              ) {
                currentSign++
              }
            }
          } else if (gamestate === "finished") {
            return
          }
        }
      } else {
        // no hand found -> reset stable counters
        stableLetterRef.current = ""
        stableCountRef.current = 0
      }

      // Draw hand lines
      const ctx = canvasRef.current.getContext("2d")
      drawHand(hand, ctx)
    }
  }

  useEffect(() => {
    runHandpose()
    // cleanup: stop TTS if leaving
    return () => {
      try {
        window.speechSynthesis.cancel()
      } catch (e) {}
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  function turnOffCamera() {
    setCamState(prev => (prev === "on" ? "off" : "on"))
  }

  // UI helpers (space, backspace, speak)
  function addSpace() {
    setConstructedWord(prev => {
      const next = prev + " "
      sendToAppInventor(`WORD:${next}`)
      return next
    })
  }
  function backspace() {
    setConstructedWord(prev => {
      const next = prev.slice(0, -1)
      sendToAppInventor(`WORD:${next}`)
      return next
    })
  }
  function speakWord() {
    const text = constructedWord || ""
    try {
      const utter = new SpeechSynthesisUtterance(text)
      window.speechSynthesis.speak(utter)
    } catch (e) {}
  }

  return (
    <ChakraProvider>
      <Metatags />
      <Box bgColor="#5784BA">
        <Container centerContent maxW="xl" height="100vh" pt="0" pb="0">
          <VStack spacing={4} align="center">
            <Box h="20px"></Box>
            <Heading
              as="h3"
              size="md"
              className="tutor-text"
              color="white"
              textAlign="center"
            ></Heading>
            <Box h="20px"></Box>
          </VStack>

          <Heading
            as="h1"
            size="lg"
            id="app-title"
            color="white"
            textAlign="center"
          >
            🧙‍♀️ Loading the Magic 🧙‍♂️
          </Heading>

          <Box id="webcam-container" position="relative">
            {camState === "on" ? (
              <Webcam id="webcam" ref={webcamRef} />
            ) : (
              <div id="webcam" style={{ background: "black", height: 300 }}></div>
            )}

            {sign ? (
              <div
                style={{
                  position: "absolute",
                  marginLeft: "auto",
                  marginRight: "auto",
                  right: "calc(50% - 50px)",
                  bottom: 100,
                  textAlign: "-webkit-center",
                }}
              >
                <Text color="white" fontSize="sm" mb={1}>
                  detected gestures
                </Text>
                <img
                  alt="signImage"
                  src={
                    Signimage[sign]?.src
                      ? Signimage[sign].src
                      : "/loveyou_emoji.svg"
                  }
                  style={{
                    height: 30,
                  }}
                />
              </div>
            ) : (
              " "
            )}
          </Box>

          <canvas id="gesture-canvas" ref={canvasRef} style={{}} />

          <Box id="singmoji" style={{ zIndex: 9, position: "fixed", top: "50px", right: "30px" }} />

          <Image h="150px" objectFit="cover" id="emojimage" />

          {/* Controls for word editing */}
          <Stack id="start-button" spacing={4} direction="row" align="center" mt={4}>
            <Button
              leftIcon={camState === "on" ? <RiCameraFill size={20} /> : <RiCameraOffFill size={20} />}
              onClick={turnOffCamera}
              colorScheme="orange"
            >
              Camera
            </Button>

            <Button onClick={addSpace} colorScheme="teal">Space</Button>
            <Button onClick={backspace} colorScheme="red">Backspace</Button>
            <Button onClick={speakWord} colorScheme="green">Speak</Button>
            <About />
          </Stack>

          <Box mt={6} mb={6}>
            <Text color="white" fontSize="lg">Constructed word: <strong style={{color:"#fff"}}>{constructedWord}</strong></Text>
          </Box>
        </Container>
      </Box>
    </ChakraProvider>
  )
}
